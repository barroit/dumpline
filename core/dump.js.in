/* SPDX-License-Identifier: GPL-3.0-or-later */
/*
 * Copyright 2025 Jiamu Sun <barroit@linux.com>
 */

import { cfg_read, cfg_write_p } from './config.js'
import line_style from './line.css'

const LINE_HEIGHT = 0
let LINE_HEIGHT_RATIO
const LINE_HEIGHT_MIN = 8

const scale = window.devicePixelRatio

const canvas_box = document.getElementById('canvas-box')
const canvas = document.getElementById('canvas')
const buffer = document.getElementById('buffer')

const banner = document.getElementById('banner')
const button = document.getElementById('button')
const link = document.getElementById('link')

let dumpline
let ctx

let binary
let blob
let complete

let line_height_defined = 0
let line_number_color_defined = 0

function info(str)
{
	dumpline.postMessage({ info: str })
}

function warn(str)
{
	dumpline.postMessage({ warn: str })
}

function error(str)
{
	dumpline.postMessage({ error: str })
}

function css_prop(styles, name)
{
	return styles.getPropertyValue(name)
}

function enabled(config, ...path)
{
	return cfg_read(config, ...path) == 'enabled'
}

/*
 * No API? Fine. We just went ahead and built the damn thing ourselves.
 *
 * src/vs/editor/common/config/fontInfo.ts:_create()
 */
function line_height_calc(h, scale)
{
	if (h == 0)
		h = LINE_HEIGHT_RATIO * scale
	else if (h < LINE_HEIGHT_MIN)
		h *= scale

	h = Math.round(h)
	return h < LINE_HEIGHT_MIN ? LINE_HEIGHT_MIN : h
}

function define_line_number_color(root, styles)
{
	const fg = css_prop(styles, '--vscode-editorLineNumber-foreground')

	root.style.setProperty('--39-line-number-color', fg)
	line_number_color_defined = 1
}

function define_line_height(config, root, styles)
{
	const font_size = css_prop(styles, '--vscode-editor-font-size')
	let line_height = cfg_read(config, 'editor', 'lineHeight')

	if (!Number.isInteger(line_height))
		line_height = LINE_HEIGHT
	line_height = line_height_calc(line_height, parseInt(font_size))

	cfg_write_p(config, 'editor', 'lineHeight', line_height)
	root.style.setProperty('--39-line-height', `${ line_height }px`)
	line_height_defined = 1
}

function parse_text(text, styles)
{
	const foreground = css_prop(styles, '--vscode-editor-foreground')
	const background = css_prop(styles, '--vscode-editor-background')
	const font_family = css_prop(styles, '--vscode-editor-font-family')
	const font_weight = css_prop(styles, '--vscode-editor-font-weight')
	const fone_size = css_prop(styles, '--vscode-editor-font-size')
	const line_height = css_prop(styles, '--39-line-height')

	let out = `<div style="color: ${ foreground }; ` +
			      `background-color: ${ background }; ` +
			      `font-family: ${ font_family }; ` +
			      `font-weight: ${ font_weight }; ` +
			      `font-size: ${ fone_size }; ` +
			      `line-height: ${ line_height }; ` +
			      'white-space: pre">'

	const lines = text.split('\n')
	const san = document.createElement('div')

	for (const line of lines) {
		if (line == '') {
			out +='<br>'
			continue
		}

		san.textContent = line
		out += '<div>' +
			 `<span style="color: ${ foreground }">` +
			    san.innerHTML +
			 '</span>' +
		       '</div>'
	}

	out += '</div>'
	return out
}

function clipboard_as_html(transfer)
{
	const data = transfer.getData('text/html')

	if (data)
		return data

	const text = transfer.getData('text/plain')
	const styles = getComputedStyle(canvas)

	return parse_text(text, styles)
}

function digitlen(n)
{
	return (Math.log10(n) >>> 0) + 1
}

function empty_line()
{
	const div = document.createElement('div')
	const span = document.createElement('span')
	const br = document.createElement('br')

	span.style.visibility = 'hidden'
	span.textContent = '\u200b'

	div.appendChild(span)
	div.appendChild(br)
	div.dataset.empty = ''

	return div
}

function canonicalize_node(box)
{
	let next = box.firstElementChild
	const alt = empty_line()

	do {
		if (next.tagName != 'BR' && next.firstElementChild)
			continue

		const clone = alt.cloneNode(true)

		box.replaceChild(clone, next)
		next = clone
	} while (next = next.nextElementSibling)
}

function setup_line_number(box)
{
	const start = ctx.block.start.line + 1
	const end = ctx.block.end.line + 1

	let next = box.firstElementChild
	let line = start

	const width = digitlen(end)
	const table = Array(width + 1).fill(' ')
				      .map((s, i) => s.repeat(i)).reverse()

	const newline = empty_line()

	do {
		const idx = digitlen(line)

		next.dataset.number = `${ table[idx] }${ line }`

		line++
	} while (next = next.nextElementSibling)
}

function trim_newline(box)
{
	let next = box.lastElementChild

	do {
		if (next.dataset.empty == undefined)
			break

		box.removeChild(next)
	} while (next = box.lastElementChild)
}

async function image_render(event, done)
{
	const img = event.target
	const d2 = buffer.getContext('2d')

	d2.setTransform(scale, 0, 0, scale, 0, 0)
	d2.drawImage(img, 0, 0)

	blob = await new Promise(ret => buffer.toBlob(ret))
	if (blob)
		binary = await blob.arrayBuffer()

	done()
}

async function image_dump(event)
{
	if (!ctx.ready) {
		error('Command palette required')
		return
	}
	ctx.ready = 0

	const root = document.documentElement
	const styles = getComputedStyle(canvas)

	if (!line_height_defined)
		define_line_height(ctx.config, root, styles)
	if (!line_number_color_defined)
		define_line_number_color(root, styles)

	canvas.innerHTML = clipboard_as_html(event.clipboardData)

	const codebox = canvas.firstElementChild

	canonicalize_node(codebox)

	if (enabled(ctx.config, '39dump', 'lineNumber'))
		setup_line_number(codebox)
	else
		codebox.classList.add('line-number-disabled')

	if (enabled(ctx.config, '39dump', 'trimNewline'))
		trim_newline(codebox)

	codebox.id = 'codebox'

	const clone = canvas_box.cloneNode(true)
	const w = codebox.offsetWidth
	const h = codebox.offsetHeight

	clone.setAttribute('width', w)
	clone.setAttribute('height', h)
	buffer.width = w * scale
	buffer.height = h * scale

	const style = document.createElement('style')

	style.textContent = line_style
	clone.prepend(style)

	const serializer = new XMLSerializer()
	const str = serializer.serializeToString(clone)

	const uri = encodeURIComponent(str)
	const b64 = `data:image/svg+xml;charset=utf-8,${ uri }`
	const img = new Image()

	await new Promise(done =>
	{
		img.src = b64
		img.onload = (event) => image_render(event, done)
	})

	if (blob)
		dumpline.postMessage({ binary })
}

function image_dump_clipboard()
{
	if (!blob) {
		warn('Nothing to be done')
		return
	}

	const data = {
		[ blob.type ]: blob,
	}
	const item = new ClipboardItem(data)

	navigator.clipboard.write([ item ])
	info('Image copied to clipboard')
}

async function context_handler(event)
{
	if (event.type =='paste') {
		image_dump(event)
		return
	}

	if (banner.contains(event.target))
		return

	if (!document.hasFocus())
		await new Promise(r => complete = r)

	const selection = window.getSelection()

	if (selection.isCollapsed)
		image_dump_clipboard()
}

document.addEventListener('cut', context_handler)
document.addEventListener('copy', context_handler)
document.addEventListener('paste', context_handler)

window.addEventListener('focus', () =>
{
	/*
	 * Wait for focus to crawl back from context menu.
	 */
	if (complete) {
		complete()
		complete = undefined
	}
})

window.addEventListener('message', event =>
{
	if (!dumpline)
		dumpline = acquireVsCodeApi()

	ctx = event.data
	ctx.ready = 1

	LINE_HEIGHT_RATIO = ctx.platform == 'darwin' ? 1.5 : 1.35
	document.execCommand('paste')
})

link.addEventListener('click', event =>
{
	dumpline.postMessage({ open: event.target.href })
})

button.addEventListener('click', image_dump_clipboard)
button.addEventListener('contextmenu', image_dump_clipboard)

banner.addEventListener('contextmenu', event =>
{
	event.preventDefault()
})

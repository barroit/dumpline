/* SPDX-License-Identifier: GPL-3.0-or-later */
/*
 * Copyright 2025 Jiamu Sun <barroit@linux.com>
 */

import { cfg_read } from './config.js'

const scale = window.devicePixelRatio

const canvas_box = document.getElementById('canvas-box')
const canvas = document.getElementById('canvas')
const buffer = document.getElementById('buffer')

let dumpline
let ctx

let binary
let blob

/*
 * No API? Fine. We just went ahead and built the damn thing ourselves.
 *
 * src/vs/editor/common/config/fontInfo.ts:_create()
 */
const LINE_HEIGHT = 0
let LINE_HEIGHT_RATIO
const LINE_HEIGHT_MIN = 8

function line_height_calc(h, scale)
{
	if (h == 0)
		h = LINE_HEIGHT_RATIO * scale
	else if (h < LINE_HEIGHT_MIN)
		h *= scale

	h = Math.round(h)
	return h < LINE_HEIGHT_MIN ? LINE_HEIGHT_MIN : h
}

async function image_render(event, done)
{
	const img = event.target
	const d2 = buffer.getContext('2d')

	d2.setTransform(scale, 0, 0, scale, 0, 0)
	d2.drawImage(img, 0, 0)

	blob = await new Promise(ret => buffer.toBlob(ret))
	binary = await blob.arrayBuffer()

	done()
}

function parse_text(text, styles)
{
	const fg = styles.getPropertyValue('--vscode-editor-foreground')
	const bg = styles.getPropertyValue('--vscode-editor-background')
	const ff = styles.getPropertyValue('--vscode-editor-font-family')
	const fw = styles.getPropertyValue('--vscode-editor-font-weight')
	const fs = styles.getPropertyValue('--vscode-editor-font-size')
	let lh = cfg_read(ctx.config, 'editor', 'lineHeight')

	if (!Number.isInteger(lh))
		lh = LINE_HEIGHT
	lh = line_height_calc(lh, parseInt(fs))

	let out = `<div style="color: ${ fg }; ` +
			      `background-color: ${ bg }; ` +
			      `font-family: ${ ff }; ` +
			      `font-weight: ${ fw }; ` +
			      `font-size: ${ fs }; ` +
			      `line-height: ${ lh }px; ` +
			      'white-space: pre">'

	const lines = text.split('\n')
	const san = document.createElement('div')

	for (const line of lines) {
		if (line == '') {
			out +='<br>'
			continue
		}

		san.textContent = line
		out += '<div>' +
			 `<span style="color: ${ fg }">` +
			    san.innerHTML +
			 '</span>' +
		       '</div>'
	}

	out += '</div>'
	return out
}

function image_init(event)
{
	const trans = event.clipboardData
	let data = trans.getData('text/html')

	if (!data) {
		const text = trans.getData('text/plain')
		const styles = getComputedStyle(canvas)

		data = parse_text(text, styles)
	}

	canvas.innerHTML = data

	const clone = canvas_box.cloneNode(true)
	const child = canvas.firstChild

	const w = child.offsetWidth
	const h = child.offsetHeight

	clone.setAttribute('width', w)
	clone.setAttribute('height', h)

	buffer.width = w * scale
	buffer.height = h * scale

	return clone
}

async function image_save(event)
{
	if (!ctx.ready) {
		dumpline.postMessage({ error: 'command palette required' })
		return
	}
	ctx.ready = 0

	const xml = image_init(event)
	const fmter = new XMLSerializer()
	const str = fmter.serializeToString(xml)

	const uri = encodeURIComponent(str)
	const b64 = `data:image/svg+xml;charset=utf-8,${ uri }`
	const img = new Image()

	await new Promise(done =>
	{
		img.src = b64
		img.onload = (event) => image_render(event, done)
	})

	dumpline.postMessage({ binary })
}

document.addEventListener('paste', image_save)

window.addEventListener('message', event =>
{
	if (!dumpline)
		dumpline = acquireVsCodeApi()

	ctx = event.data
	ctx.ready = 1

	LINE_HEIGHT_RATIO = ctx.platform == 'darwin' ? 1.5 : 1.35
	document.execCommand('paste')
})
